<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PREDICT VIP (v1.1.1 with Hybrid) </title> <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&display=swap" rel="stylesheet"/>
    <style>
        :root {
            /* --- Color Palette --- */
            --accent-primary: #2dd4bf; --accent-secondary: #14b8a6;
            --text-primary: #e2e8f0; --text-secondary: #94a3b8;
            --bg-primary: #0f172a; --bg-secondary: #1e293b;
            --card-bg: rgba(30, 41, 55, 0.85); --card-bg-darker: rgba(15, 23, 42, 0.9);
            --border-color: rgba(255, 255, 255, 0.1); --shadow-color: rgba(0, 0, 0, 0.25);
            --success-color: #4ade80; --success-color-dark: #22c55e;
            --danger-color: #f87171; --danger-color-dark: #ef4444;
            --warning-color: #facc15; --info-color: #60a5fa; --violet-color: #c084fc;
        }
        /* Base styles */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; }
        body {
            font-family: 'Montserrat', sans-serif; background: linear-gradient(145deg, var(--bg-primary), var(--bg-secondary));
            color: var(--text-primary); line-height: 1.6; min-height: 100vh; overflow-x: hidden;
            padding-top: 80px; /* Adjusted for potential wrapped nav */ position: relative;
        }
        /* Particles Background */
        #particles-js { position: fixed; width: 100%; height: 100%; top: 0; left: 0; z-index: -1; background-color: var(--bg-primary); }
        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; } ::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.1); border-radius: 3px; } ::-webkit-scrollbar-thumb { background: var(--accent-primary); border-radius: 3px; } ::-webkit-scrollbar-thumb:hover { background: var(--accent-secondary); }
        /* Navigation */
        .main-nav { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; background: var(--card-bg-darker); padding: 0.5rem; border-bottom: 1px solid var(--border-color); box-shadow: 0 3px 10px var(--shadow-color); position: fixed; top: 0; left: 0; width: 100%; z-index: 1000; gap: 0.3rem; }
        .nav-button, .nav-link { background-color: transparent; color: var(--text-secondary); border: none; padding: 0.4rem 0.6rem; border-radius: 0.375rem; cursor: pointer; font-family: inherit; font-size: 0.8rem; font-weight: 500; transition: color 0.3s, background-color 0.3s; display: inline-flex; align-items: center; gap: 0.3rem; text-decoration: none; white-space: nowrap; }
        .nav-button i, .nav-link i { font-size: 1em; width: 1.1em; text-align: center; }
        .nav-button:hover, .nav-link:hover { color: var(--text-primary); background-color: rgba(255, 255, 255, 0.1); }
        .nav-button.active { color: var(--bg-primary); background-color: var(--accent-primary); font-weight: 600; box-shadow: 0 2px 5px rgba(45, 212, 191, 0.3); }
        /* Content */
        .main-container { max-width: 1100px; margin: 1rem auto; padding: 0 0.75rem; }
        .content-view { display: none; animation: fadeIn 0.5s ease-out; } .content-view.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(15px); } to { opacity: 1; transform: translateY(0); } }
        /* Cards */
        .dashboard-card, .static-content-card { background: var(--card-bg); padding: 1rem; border-radius: 0.5rem; border: 1px solid var(--border-color); margin-bottom: 1rem; backdrop-filter: blur(8px); box-shadow: 0 4px 12px var(--shadow-color); }
        .dashboard-card h2, .static-content-card h2, .dashboard-card h3, .static-content-card h3 { color: var(--accent-primary); margin-bottom: 0.8rem; padding-bottom: 0.4rem; border-bottom: 1px solid rgba(45, 212, 191, 0.3); font-weight: 600; display: flex; align-items: center; gap: 0.5rem; }
        .dashboard-card h2, .static-content-card h2 { font-size: 1.2rem; } .dashboard-card h3, .static-content-card h3 { font-size: 1.1rem; margin-top: 1rem; }
        .dashboard-card p, .static-content-card p { margin-bottom: 0.8rem; color: var(--text-primary); font-size: 0.95rem; }
        .dashboard-card ul, .static-content-card ul { list-style: none; padding-left: 0; margin-bottom: 0.8rem; }
        .dashboard-card li, .static-content-card li { padding-left: 1.5rem; position: relative; margin-bottom: 0.5rem; font-size: 0.95rem; }
        .dashboard-card li::before, .static-content-card li::before { content: '\27A4'; color: var(--accent-primary); position: absolute; left: 0; top: 1px; font-weight: bold; font-size: 1em; }
        .static-content-card a { color: var(--accent-primary); text-decoration: none; font-weight: 500; transition: color 0.3s; }
        .static-content-card a:hover { color: var(--accent-secondary); text-decoration: underline; }
        /* Home View */
        .intro-section i.fa-crown { font-size: 2rem; margin-bottom: 0.3rem; display: block; text-align: center; color: var(--warning-color);}
        .intro-section h2 { border-bottom: none; justify-content: center; }
        .intro-section p { text-align: center; font-size: 1rem; color: var(--text-secondary); }
        .feature-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 0.8rem; }
        .feature-card { background: rgba(255, 255, 255, 0.05); padding: 0.8rem; border-radius: 0.375rem; border: 1px solid var(--border-color); text-align: center; }
        .feature-card h4 { color: var(--text-primary); font-size: 0.95rem; margin-bottom: 0.4rem; display: flex; align-items: center; justify-content: center; gap: 0.4rem; }
        .feature-card h4 i { color: var(--accent-primary); font-size: 0.9em; }
        .feature-card p { font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 0; }
        .action-button { display: inline-flex; align-items: center; gap: 0.5rem; background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); color: var(--bg-primary); padding: 0.6rem 1.2rem; border-radius: 0.375rem; font-weight: bold; transition: all 0.3s ease; border: none; cursor: pointer; font-size: 0.9rem; margin-top: 0.8rem; box-shadow: 0 3px 8px rgba(45, 212, 191, 0.3); }
        .action-button:hover { filter: brightness(1.1); transform: translateY(-1px); }
        .disclaimer-section h3 i { color: var(--warning-color); }
        /* Predictor View */
        .dashboard-grid { display: grid; grid-template-columns: 1fr; gap: 1rem; margin-top: 1rem; }
        .setup-controls { display: flex; flex-direction: column; gap: 0.8rem; margin-bottom: 1rem; }
        .setup-control-group { width: 100%; }
        .setup-control-group label { display: block; margin-bottom: 0.3rem; font-weight: 500; color: var(--text-secondary); display: inline-flex; align-items: center; gap: 0.4rem; font-size: 0.9rem; }
        .setup-control-group label i { color: var(--accent-primary); width: 1.1em; text-align: center;}
        .setup-control-group select { width: 100%; background-color: var(--card-bg-darker); border: 1px solid var(--border-color); color: var(--text-primary); padding: 0.6rem 0.8rem; border-radius: 0.375rem; font-size: 0.9rem; cursor: pointer; -webkit-appearance: none; -moz-appearance: none; appearance: none; background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%2394a3b8%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E'); background-repeat: no-repeat; background-position: right 0.7rem center; background-size: 0.65em auto; transition: border-color 0.3s; }
        .setup-control-group select:focus { outline: none; border-color: var(--accent-primary); }
        .period-input-section { margin-bottom: 1rem; text-align: center; }
        .period-input-section label { display: block; margin-bottom: 0.4rem; font-weight: 500; color: var(--text-secondary); font-size: 0.9rem;}
        .period-input-group { display: flex; align-items: stretch; gap: 0; justify-content: center; background-color: var(--card-bg-darker); border: 1px solid var(--border-color); border-radius: 0.375rem; overflow: hidden; width: 100%; max-width: 350px; margin: 0 auto; }
        .period-date-prefix { padding: 0.6rem 0.7rem; background-color: rgba(255, 255, 255, 0.05); border-right: 1px solid var(--border-color); color: var(--text-secondary); font-weight: 500; display: flex; align-items: center; font-size: 0.85rem; white-space: nowrap; }
        .period-input { background-color: transparent; border: none; color: var(--text-primary); padding: 0.6rem 0.5rem; border-radius: 0; font-size: 0.95rem; text-align: center; width: 65px; flex-grow: 1; min-width: 60px; -moz-appearance: textfield; }
        .period-input::-webkit-outer-spin-button, .period-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .period-input::placeholder { color: rgba(148, 163, 184, 0.6); }
        .period-input:focus { outline: none; background-color: rgba(255, 255, 255, 0.03); }
        #predictButton { display: inline-flex; align-items: center; gap: 0.4rem; background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); color: var(--bg-primary); padding: 0.6rem 1rem; border-radius: 0 0.375rem 0.375rem 0; font-weight: bold; transition: all 0.3s ease; border: none; cursor: pointer; font-size: 0.9rem; white-space: nowrap; border-left: 1px solid var(--border-color); }
        #predictButton:hover { filter: brightness(1.1); }
        .spinning-icon { animation: spin 1s linear infinite; margin-left: 0.4rem; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .log-message { margin-top: 0.8rem; padding: 0.7rem 1rem; border-radius: 0.375rem; text-align: center; font-weight: 500; font-size: 0.9rem; }
        .log-message.error { background-color: rgba(248, 113, 113, 0.1); border: 1px solid rgba(248, 113, 113, 0.3); color: var(--danger-color); }
        .log-message.success { background-color: rgba(74, 222, 128, 0.1); border: 1px solid rgba(74, 222, 128, 0.3); color: var(--success-color); }
        .log-message.info { background-color: rgba(96, 165, 250, 0.1); border: 1px solid rgba(96, 165, 250, 0.3); color: var(--info-color); }
        #currentPrediction { font-size: 1.3rem; font-weight: bold; text-align: center; padding: 0.8rem 0; color: var(--accent-primary); word-wrap: break-word; }
        .card-subtitle { font-size: 0.9rem; color: var(--text-secondary); text-align: center; margin-top: -0.4rem; margin-bottom: 0.8rem; }
        /* History */
        .history-stats { display: flex; flex-wrap: wrap; justify-content: space-around; gap: 0.5rem 0.8rem; margin-bottom: 0.8rem; padding: 0.6rem; background-color: var(--card-bg-darker); border-radius: 0.375rem; font-size: 0.8rem; }
        .history-stats div { color: var(--text-secondary); text-align: center;} .history-stats strong { color: var(--text-primary); font-weight: 600; }
        #historyWins { color: var(--success-color); } #historyLosses { color: var(--danger-color); } #historyAccuracy { color: var(--accent-primary); }
        .history-table-container { max-height: 250px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 0.375rem; margin-bottom: 0.8rem; }
        .history-table { width: 100%; border-collapse: collapse; }
        .history-table th, .history-table td { padding: 0.4rem 0.3rem; border-bottom: 1px solid var(--border-color); text-align: center; font-size: 0.8em; white-space: normal; /* Allow wrap */ }
        .history-table th { background-color: rgba(45, 212, 191, 0.1); color: var(--accent-primary); font-weight: 600; position: sticky; top: 0; z-index: 1; }
        .history-table tbody tr:hover { background-color: rgba(255, 255, 255, 0.07); }
        .history-table tbody tr:last-child td { border-bottom: none; }
        .status-win { color: var(--success-color); font-weight: bold; } .status-loss { color: var(--danger-color); font-weight: bold; } .status-pending { color: var(--text-secondary); font-style: italic; }
        .history-action-btn { background: none; border: 1px solid var(--border-color); color: var(--text-secondary); padding: 0.2rem 0.4rem; border-radius: 0.25rem; cursor: pointer; font-size: 0.75em; margin: 0 0.1rem; transition: all 0.2s ease; }
        .history-action-btn.win-btn:hover { background-color: var(--success-color); border-color: var(--success-color-dark); color: var(--bg-primary); }
        .history-action-btn.loss-btn:hover { background-color: var(--danger-color); border-color: var(--danger-color-dark); color: white; }
        #clearHistoryButton { display: inline-flex; align-items: center; gap: 0.4rem; background: var(--danger-color); color: white; padding: 0.4rem 0.8rem; border-radius: 0.375rem; font-weight: 500; transition: all 0.3s ease; border: none; cursor: pointer; font-size: 0.8rem; opacity: 0.8; }
        #clearHistoryButton:hover { background: var(--danger-color-dark); opacity: 1; transform: translateY(-1px); box-shadow: 0 2px 6px rgba(239, 68, 68, 0.3); }
        #historyCard .card-footer { display: flex; justify-content: flex-end; margin-top: 0.8rem; }
        /* Static Views */
        .register-list li { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem; }
        .register-list strong { margin-right: auto; font-size: 0.9rem; }
        .register-list a { background-color: var(--accent-primary); color: var(--bg-primary); padding: 0.3rem 0.8rem; border-radius: 0.25rem; font-weight: 600; text-decoration: none; transition: background-color 0.3s; white-space: nowrap; font-size: 0.8rem; }
        .register-list a:hover { background-color: var(--accent-secondary); }
        .note { font-size: 0.85rem; color: var(--text-secondary); margin-top: 0.8rem; }
        .help-heading { color: var(--info-color); font-size: 1.05rem; }
        .help-list ul { margin-left: 1.25rem; margin-top: 0.4rem; }
        .help-list ul li::before { content: '\25B8'; font-size: 0.85em; }
        .warning-box { background-color: rgba(250, 204, 21, 0.1); border: 1px solid rgba(250, 204, 21, 0.3); border-left: 3px solid var(--warning-color); padding: 0.8rem; border-radius: 0.25rem; margin-top: 1rem; }
        .warning-box h3 { border: none; padding: 0; margin-bottom: 0.4rem; color: var(--warning-color); font-size: 1rem; }
        .warning-box p { font-size: 0.9rem; margin-bottom: 0; }
        .version-info { text-align: center; color: var(--text-secondary); margin-top: 1.5rem; font-size: 0.85rem; }
        .version-info i { color: var(--danger-color); }
        /* AI Chat */
        #ai-bubble-button { position: fixed; bottom: 15px; right: 15px; width: 50px; height: 50px; border-radius: 50%; background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); color: var(--bg-primary); border: none; font-size: 1.3rem; display: flex; justify-content: center; align-items: center; cursor: pointer; box-shadow: 0 4px 12px var(--shadow-color); z-index: 1001; transition: transform 0.3s ease, box-shadow 0.3s ease; }
        #ai-bubble-button:hover { transform: scale(1.1); box-shadow: 0 6px 16px var(--shadow-color); }
        #ai-chat-popup { position: fixed; bottom: 75px; right: 15px; width: calc(100% - 30px); max-width: 320px; max-height: calc(100vh - 150px); background: var(--card-bg-darker); border-radius: 0.5rem; box-shadow: 0 5px 20px var(--shadow-color); z-index: 1000; display: none; flex-direction: column; overflow: hidden; border: 1px solid var(--border-color); backdrop-filter: blur(10px); }
        .ai-chat-header { display: flex; justify-content: space-between; align-items: center; padding: 0.6rem 0.8rem; background-color: rgba(45, 212, 191, 0.1); border-bottom: 1px solid var(--border-color); }
        .ai-chat-header span { font-weight: 600; color: var(--accent-primary); font-size: 0.95rem; }
        .ai-chat-close { background: none; border: none; color: var(--text-secondary); font-size: 1.1rem; cursor: pointer; padding: 0.2rem; }
        .ai-chat-close:hover { color: var(--text-primary); }
        #ai-chat-messages { flex-grow: 1; padding: 0.8rem; overflow-y: auto; display: flex; flex-direction: column; gap: 0.6rem; }
        .ai-message, .user-message { padding: 0.5rem 0.8rem; border-radius: 0.5rem; max-width: 85%; word-wrap: break-word; line-height: 1.4; font-size: 0.9rem; }
        .ai-message { background-color: var(--accent-primary); color: var(--bg-primary); border-bottom-left-radius: 0.25rem; align-self: flex-start; }
        .user-message { background-color: var(--info-color); color: white; border-bottom-right-radius: 0.25rem; align-self: flex-end; }
        .ai-chat-input-area { display: flex; padding: 0.6rem; border-top: 1px solid var(--border-color); background-color: rgba(15, 23, 42, 0.5); }
        #ai-chat-input { flex-grow: 1; background-color: var(--bg-secondary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 0.5rem 0.7rem; border-radius: 0.25rem 0 0 0.25rem; font-size: 0.85rem; outline: none; }
        #ai-chat-input:focus { border-color: var(--accent-primary); }
        #ai-chat-send { background-color: var(--accent-primary); color: var(--bg-primary); border: none; padding: 0 0.8rem; border-radius: 0 0.25rem 0.25rem 0; cursor: pointer; font-size: 1rem; transition: background-color 0.3s; }
        #ai-chat-send:hover { background-color: var(--accent-secondary); }

    </style>
</head>
<body>
    <div id="particles-js"></div>

    <nav class="main-nav" id="mainNav">
        <button class="nav-button active" data-view="homeView"><i class="fas fa-home"></i> Home</button>
        <button class="nav-button" data-view="predictorView"><i class="fas fa-chart-line"></i> Predictor</button>
        <button class="nav-button" data-view="registerView"><i class="fas fa-user-plus"></i> Register</button>
        <button class="nav-button" data-view="helpView"><i class="fas fa-question-circle"></i> Help</button>
        <button class="nav-button" data-view="infoView"><i class="fas fa-info-circle"></i> Info</button>
        <a href="https://chat.google.com/room/AAQA95Euqo8?cls=7" target="_blank" rel="noopener noreferrer" class="nav-link" title="Google Chat"><i class="fas fa-comment-dots"></i> Chat</a>
    </nav>

    <div class="main-container content-view active" id="homeView">
        <div class="dashboard-card intro-section">
            <i class="fas fa-crown"></i>
            <h2>Welcome to PREDICT VIP (v1.1.1 with Hybrid)</h2>
            <p>Enhance your gaming strategy with smart predictions.</p>
        </div>
        <div class="dashboard-card features-section">
            <h3><i class="fas fa-star"></i> Features</h3>
            <div class="feature-grid">
                <div class="feature-card">
                    <h4><i class="fas fa-bolt"></i> Hybrid Predictions</h4>
                    <p>Instant insights for color, size, or number.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-history"></i> Track History</h4>
                    <p>Review predictions and performance.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-sync-alt"></i> Auto-Predict Next</h4>
                    <p>Suggests next period after marking results.</p>
                </div>
                <div class="feature-card">
                    <h4><i class="fas fa-mobile-alt"></i> Mobile Optimized</h4>
                    <p>Designed for a seamless mobile experience.</p>
                </div>
            </div>
        </div>
        <div class="dashboard-card start-section">
            <h3><i class="fas fa-play-circle"></i> Get Started</h3>
            <ul>
                <li>Select Prediction <strong>Type</strong> and <strong>Interval</strong>.</li>
                <li>Enter the game <strong>Period</strong> (last 4 digits).</li>
                <li>Track results & auto-predict next!</li>
            </ul>
            <button class="action-button switch-view-button" data-target-view="predictorView"><i class="fas fa-rocket"></i> Start Predicting</button>
        </div>
        <div class="dashboard-card disclaimer-section">
            <h3><i class="fas fa-exclamation-triangle"></i> Disclaimer</h3>
            <p>Predictions are for informational purposes only. Success is not guaranteed. Play responsibly.</p>
        </div>
    </div>

    <div class="main-container content-view" id="predictorView">
        <div class="dashboard-card">
            <h2><i class="fas fa-cog"></i> Prediction Setup</h2>
            <div class="setup-controls"> <div class="setup-control-group">
                    <label for="predictionTypeSelect"><i class="fas fa-dice"></i> Type:</label>
                    <select id="predictionTypeSelect">
                        <option value="color">Color</option>
                        <option value="size">Size</option>
                        <option value="number">Number</option>
                    </select>
                </div>
                <div class="setup-control-group">
                    <label for="intervalSelect"><i class="fas fa-clock"></i> Interval:</label>
                     <select id="intervalSelect">
                        <option value="1min">1 Min</option>
                        <option value="3min">3 Min</option>
                        <option value="5min">5 Min</option>
                        <option value="10min">10 Min</option>
                    </select>
                </div>
            </div>

            <div class="period-input-section">
                 <label for="periodInput"><i class="fas fa-hashtag"></i> Enter Period</label>
                 <div class="period-input-group">
                    <span class="period-date-prefix" id="periodDatePrefix">YYYYMMDD</span>
                    <input type="text" id="periodInput" class="period-input" placeholder="Last 4" maxlength="4" pattern="\d{4}" inputmode="numeric">
                    <button id="predictButton" title="Predict using Hybrid Method">
                        <i class="fas fa-play"></i> Predict
                        <i id="predictionSpinner" class="fas fa-spinner spinning-icon" style="display: none;"></i>
                    </button>
                 </div>
            </div>

            <div id="logMessage" class="log-message" style="display: none;"></div>
        </div>
        <div class="dashboard-grid"> <div class="dashboard-card" id="predictionCard">
                 <h2><i class="fas fa-bullseye"></i> Current Prediction</h2>
                <p id="currentPrediction" class="card-subtitle">Enter period and click Predict.</p>
            </div>
            <div class="dashboard-card" id="historyCard">
                <h2><i class="fas fa-history"></i> Prediction History</h2>
                <div class="history-stats">
                     <div>Wins: <strong id="historyWins">0</strong></div>
                    <div>Losses: <strong id="historyLosses">0</strong></div>
                    <div>Acc: <strong id="historyAccuracy">0%</strong></div> <div>Rev: <strong id="historyReverse">0% (0)</strong></div> </div>
                <div class="history-table-container">
                    <table class="history-table" id="historyTable">
                        <thead>
                            <tr>
                                <th>Period</th>
                                <th>Prediction</th>
                                <th>Type</th>
                                <th>Status</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody id="historyTableBody">
                             <tr id="historyPlaceholder"><td colspan="5" style="text-align: center; color: var(--text-secondary); padding: 1rem;">No history yet.</td></tr>
                        </tbody>
                    </table>
                </div>
                 <div class="card-footer">
                     <button id="clearHistoryButton"><i class="fas fa-trash-alt"></i> Clear History</button>
                 </div>
            </div>
        </div>
    </div>

    <div class="main-container content-view" id="registerView">
        <div class="static-content-card">
            <h2><i class="fas fa-user-plus"></i> Register on Platforms</h2>
            <p>Join platforms to play. Verify safety before registering.</p>
            <ul class="register-list">
                 <li><strong>55Club:</strong> <a href="https://55club.com/#/register?invitationCode=XXXXXX" target="_blank" rel="noopener noreferrer">Register</a></li>
                <li><strong>TC Lottery:</strong> <a href="https://tclottery.com/#/register?invitationCode=YYYYYY" target="_blank" rel="noopener noreferrer">Register</a></li>
                <li><strong>Big Daddy:</strong> <a href="https://www.bdggamebigdaddygame.com//#/register?invitationCode=3783710836033" target="_blank" rel="noopener noreferrer">Register</a></li>
                <li><strong>91 Club:</strong> <a href="https://www.gyIndia.com/#/register?invitationCode=8828612752009" target="_blank" rel="noopener noreferrer">Register</a></li>
             </ul>
            <p class="note">Note: Example links. Replace codes if needed. We are not affiliated.</p>
        </div>
    </div>

    <div class="main-container content-view" id="helpView">
        <div class="static-content-card">
            <h2><i class="fas fa-question-circle"></i> Help & FAQ</h2>
            <p>Common questions about the predictor.</p>
            <h3 class="help-heading"><i class="fas fa-rocket"></i> Getting Started</h3>
            <ul class="help-list">
                <li><strong>How to Predict?</strong>
                    <ol style="list-style-type: decimal; margin-left: 1.25rem; margin-top: 0.5rem;">
                        <li>Go to 'Predictor'.</li>
                        <li>Choose 'Type' & 'Interval'.</li>
                        <li>Enter last 4 digits of 'Period'.</li>
                        <li>Click 'Predict'.</li>
                    </ol>
                </li>
                 <li><strong>Prediction Types?</strong>
                    <ul>
                        <li><strong>Color:</strong> Green, Red, Violet.</li>
                        <li><strong>Size:</strong> Big (5-9) or Small (0-4).</li>
                        <li><strong>Number:</strong> Exact number (0-9).</li>
                    </ul>
                </li>
            </ul>
            <h3 class="help-heading"><i class="fas fa-cogs"></i> Prediction Method</h3>
            <ul class="help-list">
                <li><strong>Hybrid Method:</strong> Uses sequences, trends & smoothing automatically.</li>
            </ul>
            <h3 class="help-heading"><i class="fas fa-history"></i> History & Accuracy</h3>
            <ul class="help-list">
                <li><strong>Mark Results:</strong> Click 'Win'/'Loss' in history to track accuracy.</li>
                <li><strong>Auto-Predict Next:</strong> Next period is auto-filled after marking.</li>
                <li><strong>Accuracy:</strong> Based on marked Win/Loss results.</li>
                <li><strong>Clear History:</strong> Removes predictions for the interval.</li>
            </ul>
             <h3 class="help-heading"><i class="fas fa-sync-alt"></i> Auto Reverse</h3>
            <ul class="help-list">
                <li><strong>What?</strong> May predict opposite after losses.</li>
                <li><strong>Indication:</strong> Shows (R) in history.</li>
            </ul>
        </div>
    </div>

    <div class="main-container content-view" id="infoView">
        <div class="static-content-card">
            <h2><i class="fas fa-info-circle"></i> About PREDICT VIP (v1.1.1 with Hybrid)</h2>
            <p>Uses a Hybrid Model for statistical predictions. Use as a guide only.</p>
            <ul class="help-list">
                <li><i class="fas fa-code-branch"></i> <strong>Version:</strong> 7.3 (Mobile VIP)</li>
                <li><i class="fas fa-calendar-alt"></i> <strong>Last Updated:</strong> April 15, 2025</li>
                <li><i class="fas fa-users"></i> <strong>Developed by:</strong> Predictor Team</li>
            </ul>
            <div class="warning-box">
                <h3><i class="fas fa-exclamation-triangle"></i> Responsible Gaming</h3>
                <p>Games involve risk. Bet responsibly. Set limits.</p>
            </div>
            <p class="version-info">Built with <i class="fas fa-heart" style="color: var(--danger-color);"></i> for the community.</p>
        </div>
    </div>

    <button id="ai-bubble-button" title="Chat with AI"><i class="fas fa-robot"></i></button>
    <div id="ai-chat-popup" style="display: none;">
        <div class="ai-chat-header">
            <span>AI Assistant</span>
            <button class="ai-chat-close" id="ai-chat-close"><i class="fas fa-times"></i></button>
        </div>
        <div id="ai-chat-messages">
             <div class="ai-message">Hello! How can I help you?</div>
        </div>
        <div class="ai-chat-input-area">
            <input type="text" id="ai-chat-input" placeholder="Ask about predictions...">
            <button id="ai-chat-send"><i class="fas fa-paper-plane"></i></button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- Elements Cache ---
            const navButtons = document.querySelectorAll('.main-nav .nav-button, .main-nav .nav-link');
            const actionButtons = document.querySelectorAll('.switch-view-button');
            const contentViews = document.querySelectorAll('.content-view');
            const predictButton = document.getElementById('predictButton');
            const periodInput = document.getElementById('periodInput');
            const predictionTypeSelect = document.getElementById('predictionTypeSelect');
            const intervalSelect = document.getElementById('intervalSelect');
            const currentPredictionEl = document.getElementById('currentPrediction');
            const logMessageEl = document.getElementById('logMessage');
            const predictionSpinner = document.getElementById('predictionSpinner');
            const historyTableBody = document.getElementById('historyTableBody');
            const historyPlaceholder = document.getElementById('historyPlaceholder');
            const historyWinsEl = document.getElementById('historyWins');
            const historyLossesEl = document.getElementById('historyLosses');
            const historyAccuracyEl = document.getElementById('historyAccuracy');
            const historyReverseEl = document.getElementById('historyReverse');
            const clearHistoryButton = document.getElementById('clearHistoryButton');
            const periodDatePrefixEl = document.getElementById('periodDatePrefix');
            const aiBubble = document.getElementById('ai-bubble-button');
            const aiPopup = document.getElementById('ai-chat-popup');
            const aiClose = document.getElementById('ai-chat-close');
            // Add AI chat input/send/messages elements if implementing chat fully
            // const aiChatInput = document.getElementById('ai-chat-input');
            // const aiChatSend = document.getElementById('ai-chat-send');
            // const aiChatMessages = document.getElementById('ai-chat-messages');

            // --- State Variables ---
            let predictionHistory = []; // Holds { period, prediction, type, interval, status, reversed, number? }
            let gameHistory = []; // Holds { period, number, interval } - Ideally actual results
            let currentDatePrefix = '';

            // --- Initialization ---
            initParticles();
            initViewSwitching();
            initAIChat();
            updateDatePrefix();
            loadHistory(); // Load history from localStorage
            updateStatsDisplay(); // Initial stat display

            // --- Event Listeners ---
            predictButton.addEventListener('click', handlePrediction);
            clearHistoryButton.addEventListener('click', handleClearHistory);
            historyTableBody.addEventListener('click', handleHistoryAction); // Event delegation

            // --- Functions ---

            function initParticles() {
                if (typeof particlesJS !== 'undefined') {
                    particlesJS('particles-js', { /* Mobile Particle config... */
                        "particles": { "number": { "value": 40, "density": { "enable": true, "value_area": 600 } }, "color": { "value": "#ffffff" }, "shape": { "type": "circle" }, "opacity": { "value": 0.15, "random": true, "anim": { "enable": true, "speed": 0.6, "opacity_min": 0.05, "sync": false } }, "size": { "value": 2, "random": true }, "line_linked": { "enable": true, "distance": 100, "color": "#ffffff", "opacity": 0.1, "width": 1 }, "move": { "enable": true, "speed": 1.5, "direction": "none", "random": true, "straight": false, "out_mode": "out", "bounce": false } }, "interactivity": { "detect_on": "canvas", "events": { "onhover": { "enable": false }, "onclick": { "enable": false }, "resize": true } }, "retina_detect": true
                    });
                } else { console.error("particles.js not loaded"); }
            }

            function initViewSwitching() {
                navButtons.forEach(button => {
                    if (button.dataset.view) {
                        button.addEventListener('click', (e) => {
                            if (button.tagName === 'A' && button.getAttribute('href') === '#') { e.preventDefault(); }
                            switchView(button.dataset.view);
                        });
                    }
                });
                actionButtons.forEach(button => {
                    button.addEventListener('click', () => switchView(button.dataset.targetView));
                });
                // Initial view
                switchView('homeView');
            }

            function switchView(viewId) {
                if (!viewId) return;
                contentViews.forEach(view => view.classList.remove('active'));
                navButtons.forEach(btn => {
                    if (btn.dataset.view === viewId) { btn.classList.add('active'); }
                    else { btn.classList.remove('active'); }
                });
                const targetView = document.getElementById(viewId);
                if (targetView) targetView.classList.add('active');
            }

            function initAIChat() {
                if (aiBubble && aiPopup && aiClose) {
                    aiBubble.addEventListener('click', () => { aiPopup.style.display = aiPopup.style.display === 'flex' ? 'none' : 'flex'; });
                    aiClose.addEventListener('click', () => { aiPopup.style.display = 'none'; });
                }
                // Add listeners for aiChatSend etc. if implementing chat logic
            }

            function updateDatePrefix() {
                if (periodDatePrefixEl) {
                    const now = new Date();
                    const year = now.getFullYear();
                    const month = String(now.getMonth() + 1).padStart(2, '0');
                    const day = String(now.getDate()).padStart(2, '0');
                    currentDatePrefix = `${year}${month}${day}`;
                    periodDatePrefixEl.textContent = currentDatePrefix;
                }
            }

            function showLogMessage(message, type = 'info') {
                if (logMessageEl) {
                    logMessageEl.textContent = message;
                    logMessageEl.className = `log-message ${type}`;
                    logMessageEl.style.display = message ? 'block' : 'none';
                    // Auto-clear message after a few seconds?
                    if (message && type !== 'error') { // Keep errors visible longer?
                        setTimeout(() => {
                            if (logMessageEl.textContent === message) { // Avoid clearing newer messages
                                logMessageEl.style.display = 'none';
                            }
                        }, 3500);
                    }
                }
            }

            function handlePrediction() {
                // const platform = 'DefaultPlatform'; // Platform removed
                const predictionType = predictionTypeSelect.value;
                const interval = intervalSelect.value;
                const periodSuffix = periodInput.value.trim();

                // --- Validation ---
                if (!periodSuffix || !/^\d{4}$/.test(periodSuffix)) {
                    showLogMessage('Please enter the last 4 digits of the period.', 'error');
                    periodInput.focus();
                    return;
                }
                const fullPeriod = currentDatePrefix + periodSuffix;
                if (predictionHistory.some(p => p.period === fullPeriod && p.interval === interval)) {
                     showLogMessage(`Period ${fullPeriod} already predicted for ${interval}.`, 'error');
                     return;
                }


                // --- UI Updates ---
                predictionSpinner.style.display = 'inline-block';
                predictButton.disabled = true;
                currentPredictionEl.textContent = 'Calculating...';
                currentPredictionEl.style.color = 'var(--text-secondary)'; // Reset color
                showLogMessage('');

                // --- Fetch History for Model ---
                // Filter history for the specific interval
                const relevantHistory = gameHistory // Use ACTUAL game history if available
                    .filter(item => item.interval === interval) // Filter only by interval now
                    .slice(0, 50); // Limit history size

                // --- Simulate Prediction ---
                setTimeout(() => {
                    try {
                        // Generate base prediction using Hybrid Model
                        const basePrediction = analyzeTimeSeriesHybrid(relevantHistory); // Needs history with 'number'

                        // Auto Reverse Logic Placeholder (implement if needed)
                        let isReversed = false;
                        // Example check (needs proper implementation):
                        // if (checkConsecutiveLosses(interval) >= 2) {
                        //    isReversed = true;
                        //    // Modify basePrediction.color / basePrediction.size
                        // }

                        // Format result based on selected type
                        const formattedResult = formatPredictionResult(basePrediction, predictionType);

                        // Display Prediction
                        currentPredictionEl.textContent = formattedResult;
                        applyResultColor(currentPredictionEl, formattedResult, predictionType, basePrediction.number);


                        // Add to Prediction History (User's predictions)
                        const newPrediction = {
                            period: fullPeriod,
                            prediction: formattedResult,
                            type: predictionType,
                            interval: interval, // Store interval context
                            status: 'Pending',
                            reversed: isReversed,
                            // Store base number for potential use even if predicting color/size
                            predictedNumber: basePrediction.number
                        };
                        addPredictionToHistory(newPrediction);

                        showLogMessage(`Prediction for ${fullPeriod} (${interval}): ${formattedResult}. Mark result later.`, 'success');
                        // periodInput.value = ''; // Don't clear, wait for auto-predict next

                    } catch (error) {
                        console.error("Prediction Error:", error);
                        showLogMessage('Prediction failed. Check console.', 'error');
                        currentPredictionEl.textContent = 'Error';
                        currentPredictionEl.style.color = 'var(--danger-color)';
                    } finally {
                        predictionSpinner.style.display = 'none';
                        predictButton.disabled = false;
                    }
                }, 300); // Shorter delay
            }

            function applyResultColor(element, resultText, predictionType, number = null) {
                 element.style.color = 'var(--accent-primary)'; // Default
                 if (predictionType === 'color') {
                     const lowerResult = resultText.toLowerCase();
                     if (lowerResult.includes('green')) element.style.color = 'var(--success-color)';
                     else if (lowerResult.includes('red')) element.style.color = 'var(--danger-color)';
                     if (lowerResult.includes('violet')) element.style.color = 'var(--violet-color)'; // Violet overrides
                 } else if (predictionType === 'size') {
                     if (resultText === 'Big') element.style.color = 'var(--warning-color)';
                     else if (resultText === 'Small') element.style.color = 'var(--info-color)';
                 } else if (predictionType === 'number' && number !== null) {
                     const numInfo = getNumberColorInfo(number);
                     if (numInfo.class === 'num-green') element.style.color = 'var(--success-color)';
                     else if (numInfo.class === 'num-red') element.style.color = 'var(--danger-color)';
                     else if (numInfo.class === 'num-violet') element.style.color = 'var(--violet-color)';
                 }
            }

            // --- History Management ---
            function loadHistory() {
                const savedHistory = localStorage.getItem('wingoPredictionHistory_v2');
                // ALSO load gameHistory if you store actual results separately
                // const savedGameHistory = localStorage.getItem('wingoGameHistory_v2');
                try {
                    predictionHistory = savedHistory ? JSON.parse(savedHistory) : [];
                    // gameHistory = savedGameHistory ? JSON.parse(savedGameHistory) : []; // Load actuals too
                } catch (e) {
                    console.error("Failed to parse history from localStorage", e);
                    predictionHistory = [];
                    // gameHistory = [];
                }
                renderHistoryTable();
            }

            function saveHistory() {
                try {
                    localStorage.setItem('wingoPredictionHistory_v2', JSON.stringify(predictionHistory));
                    // Also save gameHistory if used
                    // localStorage.setItem('wingoGameHistory_v2', JSON.stringify(gameHistory));
                } catch (e) {
                    console.error("Failed to save history to localStorage", e);
                    showLogMessage("Could not save history (storage full or restricted).", "error");
                }
            }

            function addPredictionToHistory(predictionData) {
                // Add to the beginning of the array
                predictionHistory.unshift(predictionData);
                // Limit history size (e.g., 100 entries)
                if (predictionHistory.length > 100) {
                    predictionHistory.pop();
                }
                saveHistory();
                renderHistoryTable(); // Update the visual table
                updateStatsDisplay(); // Update stats
            }

            function renderHistoryTable() {
                historyTableBody.innerHTML = ''; // Clear existing rows
                if (predictionHistory.length === 0) {
                    historyTableBody.appendChild(historyPlaceholder.cloneNode(true)); // Show placeholder if empty
                    historyPlaceholder.style.display = 'table-row'; // Make sure it's visible
                } else {
                    historyPlaceholder.style.display = 'none'; // Hide placeholder
                    predictionHistory.forEach(pred => {
                        const row = historyTableBody.insertRow();
                        row.setAttribute('data-period', pred.period); // Add data attribute for easy targeting

                        const predictionText = pred.reversed ? `${pred.prediction} <small>(R)</small>` : pred.prediction;

                        row.innerHTML = `
                            <td>${pred.period}</td>
                            <td>${predictionText}</td>
                            <td>${pred.type}</td>
                            <td><span class="status-${pred.status.toLowerCase()}">${pred.status}</span></td>
                            <td>
                                <button class="history-action-btn win-btn" data-period="${pred.period}" ${pred.status !== 'Pending' ? 'disabled' : ''}>Win</button>
                                <button class="history-action-btn loss-btn" data-period="${pred.period}" ${pred.status !== 'Pending' ? 'disabled' : ''}>Loss</button>
                            </td>
                        `;
                    });
                }
            }

            function handleHistoryAction(event) {
                const target = event.target;
                if (target.classList.contains('history-action-btn')) {
                    const period = target.dataset.period;
                    const isWin = target.classList.contains('win-btn');
                    updateHistoryStatus(period, isWin);
                }
            }

            function updateHistoryStatus(period, isWin) {
                const index = predictionHistory.findIndex(p => p.period == period); // Use == for potential string/number comparison
                if (index !== -1 && predictionHistory[index].status === 'Pending') {
                    predictionHistory[index].status = isWin ? 'Win' : 'Loss';

                    // **IMPORTANT**: Ideally, prompt user for ACTUAL number result here
                    // and add it to predictionHistory[index].actualNumber or update gameHistory
                    // For now, we'll skip this step.
                     // Example: Add the predicted number as the outcome for model training (suboptimal)
                     if (predictionHistory[index].predictedNumber !== undefined) {
                        // This is NOT ideal, use actual result if possible
                         predictionHistory[index].number = predictionHistory[index].predictedNumber;

                         // Add to gameHistory (if storing separately)
                         // This assumes gameHistory stores actual results needed by the model
                         // Add only if not already present
                         // if (!gameHistory.some(gh => gh.period == period)) {
                         //    gameHistory.unshift({
                         //       period: parseInt(period),
                         //       number: predictionHistory[index].number,
                         //       interval: predictionHistory[index].interval
                         //        // platform: predictionHistory[index].platform // if platform was stored
                         //    });
                         //    if (gameHistory.length > 100) gameHistory.pop(); // Limit size
                         // }
                     }


                    saveHistory();
                    renderHistoryTable(); // Update table display (buttons will be disabled)
                    updateStatsDisplay(); // Update W/L stats

                    // --- Auto-Predict Next ---
                    try {
                        const currentSuffix = parseInt(period.slice(-4), 10);
                        // Basic increment, assumes periods are sequential within the day
                        const nextSuffixInt = currentSuffix + 1;
                        const nextSuffix = nextSuffixInt.toString().padStart(4, '0');
                        periodInput.value = nextSuffix; // Set input for next prediction
                        showLogMessage(`Marked ${period} as ${isWin ? 'Win' : 'Loss'}. Next period ${currentDatePrefix}${nextSuffix} ready.`, 'info');
                        // Optionally clear current prediction display
                        // currentPredictionEl.textContent = '-';
                        // currentPredictionEl.style.color = 'var(--text-secondary)';
                    } catch (e) {
                        console.error("Error calculating next period:", e);
                    }
                }
            }

            function updateStatsDisplay() {
                let wins = 0;
                let losses = 0;
                let reversedCount = 0;
                let reversedWins = 0;

                predictionHistory.forEach(pred => {
                    if (pred.status === 'Win') {
                        wins++;
                        if (pred.reversed) reversedWins++;
                    } else if (pred.status === 'Lost') {
                        losses++;
                    }
                    if (pred.reversed && pred.status !== 'Pending') {
                        reversedCount++;
                    }
                });

                const totalPlayed = wins + losses;
                const accuracy = totalPlayed > 0 ? ((wins / totalPlayed) * 100).toFixed(0) : 0;
                const reverseAccuracy = reversedCount > 0 ? ((reversedWins / reversedCount) * 100).toFixed(0) : 0; // Accuracy when reversed

                historyWinsEl.textContent = wins;
                historyLossesEl.textContent = losses;
                historyAccuracyEl.textContent = `${accuracy}%`;
                // Show reverse accuracy instead of raw percentage? Or keep both? Let's show frequency and count.
                const reversedPercent = totalPlayed > 0 ? ((reversedCount / totalPlayed) * 100).toFixed(0) : 0;
                historyReverseEl.textContent = `${reversedPercent}% (${reversedCount})`;
            }

            function handleClearHistory() {
                if (confirm('Are you sure you want to clear all prediction history for this session?')) {
                    predictionHistory = [];
                    // gameHistory = []; // Clear actual results history too if needed
                    saveHistory();
                    renderHistoryTable();
                    updateStatsDisplay();
                    showLogMessage('Prediction history cleared.', 'info');
                }
            }

            // --- Hybrid Model Functions (Paste from previous response) ---
            function buildMarkovTransitionMatrix(history) { /* ... Paste function ... */
                const states = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
                const pseudoCount = 0.1;
                const matrix = Array(states.length).fill().map(() => Array(states.length).fill(pseudoCount));
                let counts = Array(states.length).fill(pseudoCount * states.length);
                for (let i = history.length - 1; i > 0; i--) {
                    const prev = history[i]?.number; const curr = history[i - 1]?.number;
                    if (prev !== undefined && curr !== undefined && states.includes(prev) && states.includes(curr)) {
                        matrix[prev][curr]++; counts[prev]++;
                    }
                }
                matrix.forEach((row, prevIdx) => {
                    const total = counts[prevIdx];
                    if (total > 0) { row.forEach((val, currIdx, arr) => arr[currIdx] = val / total); }
                });
                return matrix;
            }
            function predictWithMarkov(matrix, history) { /* ... Paste function ... */
                if (!history || history.length < 1) return Math.floor(Math.random() * 10);
                const lastNum = history[0]?.number;
                if (lastNum === undefined || !matrix[lastNum]) return Math.floor(Math.random() * 10);
                const probabilities = matrix[lastNum]; let cumulative = 0; const rand = Math.random();
                for (let i = 0; i < probabilities.length; i++) {
                    cumulative += probabilities[i] || 0; if (rand <= cumulative) return i;
                }
                return Math.floor(Math.random() * 10);
             }
            function calculateMovingAverage(history, period = 5) { /* ... Paste function ... */
                if (!history || history.length < period) return null;
                const recentNumbers = history.slice(0, period).map(h => h.number);
                if (recentNumbers.some(num => typeof num !== 'number')) return null;
                return recentNumbers.reduce((a, b) => a + b, 0) / period;
             }
            function getNumberColorInfo(num) { /* ... Paste function ... */
                if (num === null || num === undefined) return { class: 'num-normal', primary: null, secondary: null, size: null };
                const size = num >= 5 ? 'Big' : 'Small'; let primary = null; let secondary = null; let numClass = 'num-normal';
                if ([1, 3, 7, 9].includes(num)) { primary = 'Green'; numClass = 'num-green'; }
                else if ([2, 4, 6, 8].includes(num)) { primary = 'Red'; numClass = 'num-red'; }
                else if (num === 0) { primary = 'Red'; secondary = 'Violet'; numClass = 'num-violet'; }
                else if (num === 5) { primary = 'Green'; secondary = 'Violet'; numClass = 'num-violet'; }
                return { class: numClass, primary: primary, secondary: secondary, size: size };
            }
             function analyzeTimeSeriesHybrid(inputHistory) { /* ... Paste function - use inputHistory ... */
                 let historyToUse = inputHistory || []; // Use provided history
                 let randomNum = Math.floor(Math.random() * 10);
                 let basePrediction = { number: randomNum, size: randomNum >= 5 ? 'Big' : 'Small', color: '' };
                 let numInfo = getNumberColorInfo(randomNum);
                 basePrediction.color = numInfo.primary || (Math.random() > 0.5 ? 'Green' : 'Red');
                 if (numInfo.secondary) basePrediction.color += '+' + numInfo.secondary.charAt(0).toUpperCase() + numInfo.secondary.slice(1);

                 if (historyToUse && historyToUse.length >= 3) {
                     const markovMatrix = buildMarkovTransitionMatrix(historyToUse);
                     const markovPredictedNum = predictWithMarkov(markovMatrix, historyToUse);
                     const movingAvg = calculateMovingAverage(historyToUse, 5);
                     const trendInput = historyToUse.slice(0, 5); let bigCount = 0; let smallCount = 0;
                     if (trendInput.length > 0) { bigCount = trendInput.filter(h => h.number >= 5).length; smallCount = trendInput.length - bigCount; }
                     const trendPredictedSize = bigCount >= smallCount ? 'Big' : 'Small';
                     let finalPredictedNum = markovPredictedNum;
                     const finalNumInfo = getNumberColorInfo(finalPredictedNum);
                     let finalPredictedColor = finalNumInfo.primary || (Math.random() > 0.5 ? 'Green' : 'Red');
                     if (finalNumInfo.secondary) finalPredictedColor += '+' + finalNumInfo.secondary.charAt(0).toUpperCase() + finalNumInfo.secondary.slice(1);
                     basePrediction = { number: finalPredictedNum, size: trendPredictedSize, color: finalPredictedColor };
                 }
                 return basePrediction;
             }
             function formatPredictionResult(prediction, predictionType) { /* ... Paste function ... */
                 switch (predictionType) {
                     case 'color': return prediction.color || 'N/A';
                     case 'size': return prediction.size || 'N/A';
                     case 'number': return prediction.number !== null ? prediction.number.toString() : 'N/A';
                     default: return 'Invalid Type';
                 }
              }

        }); // End DOMContentLoaded
    </script>

</body>
</html>